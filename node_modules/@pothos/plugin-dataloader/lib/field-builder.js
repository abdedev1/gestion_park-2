"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _core = require("@pothos/core");
const _util = require("./util");
const fieldBuilderProto = _core.RootFieldBuilder.prototype;
fieldBuilderProto.loadable = function loadable({ load, sort, loaderOptions, resolve, type, byPath, ...options }) {
    const getLoader = (0, _util.pathDataloaderGetter)(loaderOptions, (keys, ctx, args)=>load(keys, ctx, args), undefined, sort, byPath);
    return this.field({
        ...options,
        type,
        // @ts-expect-error types don't match because this handles both lists and single objects
        resolve: async (parent, args, context, info)=>{
            const ids = await resolve(parent, args, context, info);
            if (ids == null) {
                return null;
            }
            const loader = getLoader(args, context, info);
            if (Array.isArray(type)) {
                return (0, _util.rejectErrors)(ids.map((id)=>id == null ? id : loader.load(id)));
            }
            return loader.load(ids);
        }
    });
};
fieldBuilderProto.loadableList = function loadableList({ load, sort, loaderOptions, resolve, type, byPath, ...options }) {
    const getLoader = (0, _util.pathDataloaderGetter)(loaderOptions, (keys, ctx, args)=>load(keys, ctx, args), undefined, sort, byPath);
    return this.field({
        ...options,
        type: [
            type
        ],
        // @ts-expect-error types don't match because this handles both lists and single objects
        resolve: async (parent, args, context, info)=>{
            const ids = await resolve(parent, args, context, info);
            const loader = getLoader(args, context, info);
            return loader.load(ids);
        }
    });
};
fieldBuilderProto.loadableGroup = function loadableGroup({ load, group, loaderOptions, byPath, resolve, type, ...options }) {
    const getLoader = (0, _util.pathDataloaderGetter)(loaderOptions, async (keys, ctx, args)=>{
        const values = await load(keys, ctx, args);
        const groups = new Map();
        for (const value of values){
            if (value == null) {
                continue;
            }
            const groupKey = group(value);
            if (!groups.has(groupKey)) {
                groups.set(groupKey, []);
            }
            groups.get(groupKey).push(value);
        }
        return keys.map((key)=>{
            var _groups_get;
            return (_groups_get = groups.get(key)) !== null && _groups_get !== void 0 ? _groups_get : [];
        });
    }, undefined, false, byPath);
    return this.field({
        ...options,
        type: [
            type
        ],
        // @ts-expect-error types don't match because this handles both lists and single objects
        resolve: async (parent, args, context, info)=>{
            const ids = await resolve(parent, args, context, info);
            const loader = getLoader(args, context, info);
            return loader.load(ids);
        }
    });
};

//# sourceMappingURL=field-builder.js.map