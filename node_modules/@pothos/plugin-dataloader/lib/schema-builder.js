"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _core = /*#__PURE__*/ _interop_require_wildcard(require("@pothos/core"));
const _refs = require("./refs");
const _interface = require("./refs/interface");
const _object = require("./refs/object");
const _union = require("./refs/union");
const _util = require("./util");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const schemaBuilderProto = _core.default.prototype;
schemaBuilderProto.loadableObjectRef = function loadableObjectRef(name, options) {
    return new _object.ImplementableLoadableObjectRef(this, name, options);
};
schemaBuilderProto.loadableInterfaceRef = function loadableInterfaceRef(name, options) {
    return new _interface.ImplementableLoadableInterfaceRef(this, name, options);
};
schemaBuilderProto.loadableNodeRef = function loadableNodeRef(name, options) {
    return new _refs.ImplementableLoadableNodeRef(this, name, options);
};
schemaBuilderProto.loadableObject = function loadableObject(nameOrRef, options) {
    var _options_name;
    const name = typeof nameOrRef === 'string' ? nameOrRef : (_options_name = options.name) !== null && _options_name !== void 0 ? _options_name : nameOrRef.name;
    const ref = new _object.ImplementableLoadableObjectRef(this, name, options);
    ref.implement(options);
    if (typeof nameOrRef !== 'string') {
        this.configStore.associateRefWithName(nameOrRef, name);
    }
    return ref;
};
schemaBuilderProto.loadableInterface = function loadableInterface(nameOrRef, options) {
    var _options_name;
    const name = typeof nameOrRef === 'string' ? nameOrRef : (_options_name = options.name) !== null && _options_name !== void 0 ? _options_name : nameOrRef.name;
    const ref = new _interface.ImplementableLoadableInterfaceRef(this, name, options);
    ref.implement(options);
    if (typeof nameOrRef !== 'string') {
        this.configStore.associateRefWithName(nameOrRef, name);
    }
    return ref;
};
schemaBuilderProto.loadableUnion = function loadableUnion(name, { load, toKey, sort, cacheResolved, loaderOptions, ...options }) {
    const getDataloader = (0, _util.dataloaderGetter)(loaderOptions, load, toKey, sort);
    const ref = new _union.LoadableUnionRef(name, getDataloader);
    this.unionType(name, {
        ...options,
        extensions: {
            getDataloader,
            cacheResolved: typeof cacheResolved === 'function' ? cacheResolved : cacheResolved && toKey
        }
    });
    this.configStore.associateRefWithName(ref, name);
    return ref;
};
const TloadableNode = schemaBuilderProto.loadableNode;
schemaBuilderProto.loadableNode = function loadableNode(nameOrRef, options) {
    if (typeof this.nodeInterfaceRef !== 'function') {
        throw new _core.PothosSchemaError('builder.loadableNode requires @pothos/plugin-relay to be installed');
    }
    var _options_name;
    const name = typeof nameOrRef === 'string' ? nameOrRef : (_options_name = options.name) !== null && _options_name !== void 0 ? _options_name : nameOrRef.name;
    const ref = new _refs.ImplementableLoadableNodeRef(this, name, options);
    var _options_isTypeOf;
    ref.implement({
        ...options,
        extensions: {
            ...options.extensions,
            pothosParseGlobalID: options.id.parse
        },
        isTypeOf: (_options_isTypeOf = options.isTypeOf) !== null && _options_isTypeOf !== void 0 ? _options_isTypeOf : typeof nameOrRef === 'function' ? (maybeNode, context, info)=>{
            if (!maybeNode) {
                return false;
            }
            if (maybeNode instanceof nameOrRef) {
                return true;
            }
            const proto = Object.getPrototypeOf(maybeNode);
            try {
                if (proto === null || proto === void 0 ? void 0 : proto.constructor) {
                    const config = this.configStore.getTypeConfig(proto.constructor);
                    return config.name === name;
                }
            } catch  {
            // ignore
            }
            return false;
        } : undefined
    });
    if (typeof nameOrRef !== 'string') {
        this.configStore.associateRefWithName(nameOrRef, name);
    }
    return ref;
};

//# sourceMappingURL=schema-builder.js.map