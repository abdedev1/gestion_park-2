// src/next/rsc.ts
import { createClient as create, fetchExchange } from "@urql/core";
import {
  execute as graphQLExecute,
  print
} from "graphql";
import { builder } from "fuse";
import { registerUrql } from "@urql/next/rsc";
export * from "@urql/core";

// src/exchanges/cache.ts
import { cacheExchange as urqlCacheExchange } from "@urql/core";
import { pipe, tap } from "wonka";
var cacheExchange = ({ forward, client, dispatchDebug }) => {
  const cache$ = urqlCacheExchange({ client, dispatchDebug, forward });
  const warned = /* @__PURE__ */ new Set();
  return (ops$) => {
    return pipe(
      cache$(ops$),
      tap((result) => {
        if (process.env.NODE_ENV === "production")
          return;
        if (warned.has(result.operation.key))
          return;
        if (result.operation.kind === "mutation" && !result.operation.context.additionalTypenames) {
          Object.entries(result.data).forEach(([key, value]) => {
            if (value != null && typeof value !== "object") {
              warned.add(result.operation.key);
              console.warn(
                `Saw return of type "${typeof value}" for "${key}", returning scalar values can lead to stale cache-entires. Consider using "additionalTypenames" to correctly evict cache-entries affected by this mutation.`
              );
            }
          });
        } else if (result.operation.kind === "query" && !result.operation.context.additionalTypenames) {
          Object.entries(result.data).forEach(([key, value]) => {
            if (value == null) {
              warned.add(result.operation.key);
              console.warn(
                `Saw return value of "null" for "${key}", we aren't able to derive an associated type for this key, this means that a mutation won't be able to evict this query. Consider using "additionalTypenames" to correctly evict this cache-entry.`
              );
            } else if (Array.isArray(value) && value.length === 0) {
              warned.add(result.operation.key);
              console.warn(
                `Saw an empty array for "${key}", we aren't able to derive an associated type for members of this list, this means that a mutation won't be able to evict this query. Consider using "additionalTypenames" to correctly evict this cache-entry.`
              );
            } else if (value != null && typeof value === "object") {
              const data = value;
              if (data.nodes && Array.isArray(data.nodes) && data.nodes.length === 0) {
                warned.add(result.operation.key);
                console.warn(
                  `Saw an empty array for "${key}.nodes", we aren't able to derive an associated type for members of this list, this means that a mutation won't be able to evict this query. Consider using "additionalTypenames" to correctly evict this cache-entry.`
                );
              } else if (data.edges && Array.isArray(data.edges) && data.edges.length === 0) {
                warned.add(result.operation.key);
                console.warn(
                  `Saw an empty array for "${key}.edges", we aren't able to derive an associated type for members of this list, this means that a mutation won't be able to evict this query. Consider using "additionalTypenames" to correctly evict this cache-entry.`
                );
              }
            }
          });
        }
      })
    );
  };
};

// src/next/rsc.ts
var convertNullprototype = (obj) => {
  if (obj == null || typeof obj !== "object")
    return obj;
  if (Array.isArray(obj)) {
    return obj.map(convertNullprototype);
  } else if (typeof obj === "object") {
    return Object.keys(obj).reduce(
      (acc, key) => {
        acc[key] = convertNullprototype(obj[key]);
        return acc;
      },
      {}
    );
  }
};
var __internal_execute = async (request) => {
  const params = {
    query: print(request.query),
    variables: request.variables || {}
  };
  const allContext = {
    ...request.context ? request.context(params) : {},
    params
  };
  const result = await graphQLExecute({
    document: request.query,
    schema: builder.toSchema(),
    variableValues: request.variables || {},
    contextValue: allContext
  });
  return convertNullprototype(result);
};
var createClient = (opts) => {
  const options = {
    ...opts,
    exchanges: opts.exchanges || [fetchExchange]
  };
  return create(options);
};
export {
  __internal_execute,
  cacheExchange,
  createClient,
  registerUrql as registerClient
};
